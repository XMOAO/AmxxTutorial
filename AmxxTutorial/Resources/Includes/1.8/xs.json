{
    "functions": [
        {
            "Comment": "**** BASIC STUFF *****",
            "CommentTags": [],
            "FunctionName": "Float:xs_fabs",
            "Function": "#if XS_PLATFORM == XS_AMX\n\t\tenum anglemode\n\t\t{\n\t\t\tradian = 0,\n\t\t\tdegrees,\n\t\t\tgrades\n\t\t} \n\t#endif\n\t\n\t// Returns -1 if num is negative, 0 if num is 0, 1 if num is positive\n\t// tested\n\tXS_LIBFUNC_ATTRIB xs_sign(num)\n\t{\n\t\treturn (num < 0) ? -1 : ((num == 0) ? 0 : 1);\n\t}\n\t\n\t// Returns -1 if num is negative, 0 if num is 0, 1 if num is positive\n\t// tested\n\tXS_LIBFUNC_ATTRIB xs_fsign(Float:num)\n\t{\n\t\treturn (num < 0.0) ? -1 : ((num == 0.0) ? 0 : 1);\n\t}\n\t\n\t// Returns absolute value\n\t// tested\n\tXS_LIBFUNC_ATTRIB xs_abs(num)\n\t{\n\t\treturn (num < 0) ? -num : num;\n\t}\n\t\n\t// is power of 2? (== can be expressed as 1<<i)\n\t// tested\n\tXS_LIBFUNC_ATTRIB xs_is_2power(x)\n\t{\n\t\treturn (x!=0) && ((x&(x-1))==0);\n\t}\n\t\n\t// degrees to radians\n\t// tested\n\tXS_LIBFUNC_ATTRIB Float:xs_deg2rad(Float:x)\n\t{\n\t\treturn x * 0.017453292519943;\n\t}\n\t\n\t// tested\n\tXS_LIBFUNC_ATTRIB Float:xs_rad2deg(Float:x)\n\t{\n\t\treturn x * 57.29577951308232;\n\t}\n\t\n\t// untested, should work though\n\tXS_LIBFUNC_ATTRIB Float:xs_gra2rad(Float:x)\n\t{\n\t\treturn x * 0.015707963267948;\n\t}\n\t\n\t// untested, should work though\n\tXS_LIBFUNC_ATTRIB Float:xs_rad2gra(Float:x)\n\t{\n\t\treturn x * 63.66197723675813;\n\t}\n\t\n\t// Only works when there is no whitespace between %1, the comma and %2...\n\t// tested\n\t#define XS_FLEQ(%1,%2) (((%1) <= ((%2) + XS_FLEQ_TOLERANCE)) && ((%1) >= ((%2) - XS_FLEQ_TOLERANCE)))\n\n\t// 1/sqrt\n\t// tested\n\tXS_LIBFUNC_ATTRIB Float:xs_rsqrt(Float:x)\n\t{\n\t\t#if XS_PLATFORM == XS_AMX\n\t\t\t// store half\n\t\t\tnew Float:xhalf = x * 0.5;\n\t\t\t\n\t\t\t// compute initial guess\n\t\t\tnew i = _:x;\n\t\t\ti = 0x5f375a84 - (i >> 1);\n\t\t\tx = Float:i;\n\t\t\t\n\t\t\t// refine 3 times\n\t\t\tx = x * (1.5 - xhalf * x * x);\n\t\t\tx = x * (1.5 - xhalf * x * x);\n\t\t\tx = x * (1.5 - xhalf * x * x);\n\t\t\t\n\t\t\treturn x;\n\t\t#else\n\t\t\treturn 1.0 / floatsqroot(x);\n\t\t#endif\n\t}\n\t\n\t// sqrt\n\t// tested\n\tXS_LIBFUNC_ATTRIB Float:xs_sqrt(Float:x)\n\t{\n\t\t#if XS_PLATFORM == XS_AMX\n\t\t\t// 1.0 / rsqrt should still be faster than loop-using-approximation-methods\n\t\t\treturn 1.0 / xs_rsqrt(x);\n\t\t#else\n\t\t\treturn floatsqroot(x);\n\t\t#endif\n\t}\n\t\n\t// These functions generate errors if you use the macros with wrong parameter count.\n\tstock Float:xs_fabs(Float:pa)"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_asin(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_asin"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_sin(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_sin"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_acos(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_acos"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_cos(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_cos"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_atan(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_atan"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_atan2(Float:pa,Float:pb)",
            "FunctionName": "Float:xs_atan2"
        },
        {
            "Comment": "This function has no description.",
            "CommentTags": [],
            "Function": "stock Float:xs_tan(Float:pa, Float:pb)",
            "FunctionName": "Float:xs_tan"
        }
    ],
    "constants": [
        {
            "Comment": "**** DEBUGGING / LOGING FUNCTIONS *****",
            "CommentTags": [],
            "Constant": "enum xs_logtypes\n    {\n        xs_debug,\n        xs_message,\n        xs_warning,\n        xs_error,\n        xs_fatalerror,\n        xs__assertionfailed,\n        \n        // must come last\n        xs_logtypes_count\n    }\n    \n    XS_LIBVAR_ATTRIB const xs__logtypenames[xs_logtypes_count][] = {\"DEBUG\", \"\", \"WARNING\", \"ERROR\", \"FATAL ERROR\", \"DEBUG ASSERTION FAILED\"};\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_log(xs_logtypes:logtype, {Float,_}:...)\n    {\n        // WARNING: Don't try to use assert in here; it uses this func\n        \n        // Don't log debug if not in debug mode\n        #if !XS_DEBUG\n            if (logtype == xs_debug)\n                return;\n        #endif\n    \n        new buffer[XS_LOGBUFFER_SIZE+1];\n        buffer[XS_LOGBUFFER_SIZE]=0;\n        format_args(buffer, XS_LOGBUFFER_SIZE, 1 /* go from SECOND argument*/);\n        new bool:addLogTypeName = strlen(xs__logtypenames[logtype]) ? true : false;\n    \n        #if XS_PLATFORM == XS_AMX\n            new plugname[32];\n            new dummy[1];\n            get_plugin(-1, plugname, 31, dummy, 0, dummy, 0, dummy, 0, dummy, 0, dummy[0]);\n            // log into HL Logs\n            log_message(\"[AMX][%s]: %s%s%s\", plugname, addLogTypeName ? xs__logtypenames[logtype] : \"\",\n                addLogTypeName ? \": \" : \"\", buffer);\n        #else    // assume AMXX\n    \n            // Use AMXX's logging system\n            log_amx(\"%s%s%s\", addLogTypeName ? xs__logtypenames[logtype] : \"\",\n                addLogTypeName ? \": \" : \"\", buffer);    \n        #endif\n    }\n    \n    // Assertion\n    // tested\n    XS_LIBFUNC_ATTRIB xs_assertfunc({Float,_}:exp, const desc[])\n    {\n        // Check exp\n        if (exp)\n            return 1; // ok\n        \n        // not ok\n        \n        // print info\n        xs_log(xs__assertionfailed, \"%s\", desc);\n        \n        return 0;\n    }\n    #define xs_assert(%1,%2) if (!xs_assertfunc(%1,%2)) xs__global_null /= xs__global_null\n    \n    \n    // Assertion; only in debug mode\n    // untested; logical flow says it should work\n    #if XS_DEBUG\n        #define xs_assert_dbg(%1,%2) if (!xs_assertfunc(%1,%2)) xs__global_null /= xs__global_null\n    #else\n        #define xs_assert_dbg(%1,%2)\n    #endif\n    \n    new xs__global_null = 0;"
        },
        {
            "Comment": "**** MATH FUNCTIONS *****",
            "CommentTags": [],
            "Constant": ""
        },
        {
            "Comment": "**** RANDOM NUMBERS *****",
            "CommentTags": [],
            "Constant": "// This routine comes from the book \"Inner Loops\" by Rick Booth, Addison-Wesley\n    // (ISBN 0-201-47960-5). This is a \"multiplicative congruential random number\n    // generator\" that has been extended to 31-bits\n    \n    XS_LIBVAR_ATTRIB xs__internalseed=0x546875;\n    \n    #define XS__IL_RMULT 1103515245\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_seed(seed)\n    {\n        xs__internalseed = seed;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_irand()\n    {\n        new lo, hi, ll, lh, hh, hl;\n        new result;\n        \n        lo = xs__internalseed & 0xffff;\n        hi = xs__internalseed >> 16;\n        xs__internalseed = xs__internalseed * XS__IL_RMULT + 12345;\n        ll = lo * (XS__IL_RMULT  & 0xffff);\n        lh = lo * (XS__IL_RMULT >> 16    );\n        hl = hi * (XS__IL_RMULT  & 0xffff);\n        hh = hi * (XS__IL_RMULT >> 16    );\n        result = xs_abs(((ll + 12345) >> 16) + lh + hl + (hh << 16));\n        return result;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_frand()\n    {\n        return float(xs_irand()) / float(xs_get_maxnum());        // -1/2 should be the biggest possible positive number\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_irand_range(pmin, pmax)\n    {\n        xs_assert_dbg(pmax - pmin >= 0, \"xs_irand_range: pmin > pmax\");\n        new i = pmin + floatround(xs_frand() * float(pmax - pmin));\n        if (i > pmax)\n            i = pmax;\n        return i;\n    }"
        },
        {
            "Comment": "**** VECTORS & PLANES *****",
            "CommentTags": [],
            "Constant": "// *** vectors\n    \n    // Set vec components to values\n    // tested\n    XS_LIBFUNC_ATTRIB xs_vec_set(Float:vec[], Float:x, Float:y, Float:z)\n    {\n        vec[0] = x;\n        vec[1] = y;\n        vec[2] = z;\n    }\n    \n    // Add vec\n    // tested\n    XS_LIBFUNC_ATTRIB xs_vec_add(const Float:in1[], const Float:in2[], Float:out[])\n    {\n        out[0] = in1[0] + in2[0];\n        out[1] = in1[1] + in2[1];\n        out[2] = in1[2] + in2[2];\n    }\n    \n    // Subtract vec\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB xs_vec_sub(const Float:in1[], const Float:in2[], Float:out[])\n    {\n        out[0] = in1[0] - in2[0];\n        out[1] = in1[1] - in2[1];\n        out[2] = in1[2] - in2[2];\n    }\n    \n    // Are vectors equal?\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB bool:xs_vec_equal(const Float:vec1[], const Float:vec2[])\n    {\n        return (vec1[0] == vec2[0]) && (vec1[1] == vec2[1]) && (vec1[2] == vec2[2]);\n    }\n    \n    // Are vectors nearly equal?\n    // tested\n    XS_LIBFUNC_ATTRIB bool:xs_vec_nearlyequal(const Float:vec1[], const Float:vec2[])\n    {\n        return XS_FLEQ(vec1[0], vec2[0]) && XS_FLEQ(vec1[1], vec2[1]) && XS_FLEQ(vec1[2], vec2[2]);\n    }\n    \n    // multiply vector by scalar\n    // tested\n    XS_LIBFUNC_ATTRIB xs_vec_mul_scalar(const Float:vec[], Float:scalar, Float:out[])\n    {\n        out[0] = vec[0] * scalar;\n        out[1] = vec[1] * scalar;\n        out[2] = vec[2] * scalar;\n    }\n    \n    // divide vector by scalar\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB xs_vec_div_scalar(const Float:vec[], Float:scalar, Float:out[])\n    {\n        new Float:__tmp = 1.0 / scalar;\n        out[0] = vec[0] * __tmp;\n        out[1] = vec[1] * __tmp;\n        out[2] = vec[2] * __tmp;\n    }\n    \n    // Compute vector length\n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_vec_len(const Float:vec[])\n    {\n        return xs_sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);\n    }\n    \n    // Normalize vec\n    // tested\n    XS_LIBFUNC_ATTRIB xs_vec_normalize(const Float:vec[], Float:out[])\n    {\n        new Float:invlen = xs_rsqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);\n        out[0] = vec[0] * invlen;\n        out[1] = vec[1] * invlen;\n        out[2] = vec[2] * invlen;\n    }\n    \n    // Store the cross product of vec1 and vec2 in out\n    // tested\n    XS_LIBFUNC_ATTRIB xs_vec_cross(const Float:vec1[], const Float:vec2[], Float:out[])\n    {\n        out[0] = vec1[1]*vec2[2] - vec1[2]*vec2[1];\n        out[1] = vec1[2]*vec2[0] - vec1[0]*vec2[2];\n        out[2] = vec1[0]*vec2[1] - vec1[1]*vec2[0];\n    }\n    \n    // Compute vec1 dot vec2\n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_vec_dot(const Float:vec1[], const Float:vec2[])\n    {\n        return vec1[0]*vec2[0] + vec1[1]*vec2[1] + vec1[2]*vec2[2];\n    }\n    \n    // Negate vec into out\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB xs_vec_neg(const Float:vec[], Float:out[])\n    {\n        out[0] = -vec[0];\n        out[1] = -vec[1];\n        out[2] = -vec[2];\n    }\n    \n    // Copy vec\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB xs_vec_copy(const Float:vecIn[], Float:vecOut[])\n    {\n        vecOut[0] = vecIn[0];\n        vecOut[1] = vecIn[1];\n        vecOut[2] = vecIn[2];\n    }\n    \n    // Compute angle between vec1 and vec2\n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_vec_angle(const Float:vec1[], const Float:vec2[])\n    {\n        return xs_rad2deg(xs_acos(xs_vec_dot(vec1, vec2), radian));\n    }\n    \n    // Reflect vec about normal\n    // untested\n    XS_LIBFUNC_ATTRIB xs_vec_reflect(const Float:vec[], const Float:normal[], Float:out[])\n    {\n        // normalize(vec) - (normal * 2.0 * (tmp . normal)) * length(vec)\n        \n        new Float:tmp1[3];\n        xs_vec_normalize(vec, tmp1);\n        \n        // tmp1 - (normal * 2.0 * (tmp . normal)) * length(vec)\n        \n        new Float:tmp2[3];\n        xs_vec_mul_scalar(normal, 2.0, tmp2);\n        xs_vec_mul_scalar(tmp2, xs_vec_dot(tmp1, normal), tmp2);\n        \n        // tmp1 - tmp2 * length(vec)\n        xs_vec_mul_scalar(tmp2, xs_vec_len(vec), tmp2);\n        \n        // tmp1 - tmp2\n        xs_vec_sub(tmp1, tmp2, out);\n    }\n    \n    // Turn a 3D vector into a 2D vector\n    XS_LIBFUNC_ATTRIB xs_vec_make2d(const Float:vec[3], Float:out[2])\n    {\n        out[0] = vec[0];\n        out[1] = vec[1];\n    }\n    \n    // *** planes\n    \n    // normal\n    #define XS_PLANE_A 0\n    #define XS_PLANE_B 1\n    #define XS_PLANE_C 2\n    // plane shift distance\n    #define XS_PLANE_D 3\n\n\n    // Set a plane to specific values\n    // tested\n    XS_LIBFUNC_ATTRIB xs_plane_set(Float:plane[], Float:a, Float:b, Float:c, Float:d)\n    {\n        plane[XS_PLANE_A] = a;\n        plane[XS_PLANE_B] = b;\n        plane[XS_PLANE_C] = c;\n        plane[XS_PLANE_D] = d;\n    }\n    \n    // Construct a plane out of 3 points\n    // tested\n    XS_LIBFUNC_ATTRIB xs_plane_3p(Float:plane[], const Float:p1[], const Float:p2[], const Float:p3[])\n    {\n        new Float:normalA[3], Float:normalB[3];\n        \n        // normalA = Normalize(p3 - p1);\n        normalA[0] = p3[0] - p1[0];\n        normalA[1] = p3[1] - p1[1];\n        normalA[2] = p3[2] - p1[2];\n        xs_vec_normalize(normalA, normalA);\n        \n        // normalB = Normalize(p3 - p2);\n        normalB[0] = p3[0] - p2[0];\n        normalB[1] = p3[1] - p2[1];\n        normalB[2] = p3[2] - p2[2];\n        xs_vec_normalize(normalB, normalB);\n        \n        // plane normal = Normalize(normalA cross normalB)\n        xs_vec_cross(normalA, normalB, plane);\n        xs_vec_normalize(plane, plane);\n        \n        // plane shift distance = (-p1) dot plane normal\n        new Float:__tmp[3];\n        xs_vec_neg(plane, __tmp);\n        plane[XS_PLANE_D] = xs_vec_dot(__tmp, p1);\n        \n    }\n    \n    // untested, but should work\n    XS_LIBFUNC_ATTRIB bool:xs_plane_equal(const Float:plane1[], const Float:plane2[])\n    {\n        if (    (plane1[0] == plane2[0]) &&\n            (plane1[1] == plane2[1]) &&\n            (plane1[2] == plane2[2]) &&\n            (plane1[3] == plane2[3]))\n            return true;\n        return false;\n    }\n    \n    // untested, but should work\n    XS_LIBFUNC_ATTRIB bool:xs_plane_nearlyequal(const Float:plane1[], const Float:plane2[])\n    {\n        if (    XS_FLEQ(plane1[0], plane2[0]) &&\n            XS_FLEQ(plane1[1], plane2[1]) &&\n            XS_FLEQ(plane1[2], plane2[2]) &&\n            XS_FLEQ(plane1[3], plane2[3]))\n            return true;\n        return false;\n    }\n    \n    // Compute distance between plane and point\n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_plane_dst2point(const Float:plane[], const Float:point[])\n    {\n        // return normal dot point + D\n        return xs_vec_dot(plane, point) + plane[XS_PLANE_D];\n    }\n    \n    // Checks whether plane intersects with the ray starting and rayStart and going to rayDir direction.\n    // If yes, returns true and sets out to the intersection point\n    // Otherwise, returns false\n    // tested\n    XS_LIBFUNC_ATTRIB bool:xs_plane_rayintersect(const Float:plane[], const Float:rayStart[], const Float:rayDir[], Float:out[])\n    {\n        new Float:a = xs_vec_dot(plane, rayDir);\n        \n        if (a == 0.0)\n            return false;        // ray is parallel to plane\n        \n        // if (distance plane<->(rayStart + rayDir) > distance plane<->rayStart) and both have the same sign, the ray\n        // goes away from the plane\n        new Float:rsplusrd[3];\n        xs_vec_add(rayStart, rayDir, rsplusrd);\n        new Float:dst1 = xs_plane_dst2point(plane, rsplusrd);\n        new Float:dst2 = xs_plane_dst2point(plane, rayStart);\n        if (xs_fabs(dst1) > xs_fabs(dst2) && xs_fsign(dst1) == xs_fsign(dst2))\n            return false;\n        \n        \n        // out = rayStart - rayDir * ((distance plane<->rayStart) / a)\n        new Float:__tmp[3];\n        xs_vec_mul_scalar(rayDir, xs_plane_dst2point(plane, rayStart) / a, __tmp);\n        // out = rayStart - tmp\n        xs_vec_sub(rayStart, __tmp, out);\n        \n        return true;\n    }\n    \n    // Is point on plane?\n    // tested\n    XS_LIBFUNC_ATTRIB bool:xs_point_onplane(const Float:plane[], const Float:point[])\n    {\n        return XS_FLEQ(xs_plane_dst2point(plane, point), 0.0);\n    }\n    \n    // Project point on plane\n    // tested\n    XS_LIBFUNC_ATTRIB xs_projpoint_onplane(const Float:plane[], const Float:point[], Float:out[])\n    {\n        new Float:__tmp[3];\n        // out = point - (plane normal * distance point<->plane)\n        xs_vec_copy(plane, __tmp);\n        xs_vec_mul_scalar(__tmp, xs_plane_dst2point(plane, point), __tmp);\n        xs_vec_sub(point, __tmp, out);\n    }\n    \n    // Copy plane\n    // untested, but should work\n    XS_LIBFUNC_ATTRIB xs_plane_copy(const Float:planeIn[], Float:planeOut[])\n    {\n        planeOut[0] = planeIn[0];\n        planeOut[1] = planeIn[1];\n        planeOut[2] = planeIn[2];\n        planeOut[3] = planeIn[3];\n    }"
        },
        {
            "Comment": "**** HL ENGINE SPECIFIC STUFF *****",
            "CommentTags": [],
            "Constant": "// Compute forward, right and up vector from angles\n    // half-tested\n    \n    // angle indexes\n    #define    XS_PITCH                0        // up / down\n    #define    XS_YAW                    1        // left / right\n    #define    XS_ROLL                    2        // fall over\n\n    XS_LIBFUNC_ATTRIB xs_anglevectors(const Float:angles[3], Float:fwd[3], Float:right[3], Float:up[3])\n    {\n        // sin (s) and cos (c) for yaw (y), pitch (p) and roll (r)\n        new Float:sr, Float:sp, Float:sy, Float:cr, Float:cp, Float:cy;\n        \n        sy = xs_sin(angles[XS_YAW], degrees);\n        cy = xs_cos(angles[XS_YAW], degrees);\n        sp = xs_sin(angles[XS_PITCH], degrees);\n        cp = xs_cos(angles[XS_PITCH], degrees);\n        sr = xs_sin(angles[XS_ROLL], degrees);\n        cr = xs_cos(angles[XS_ROLL], degrees);\n        \n        fwd[0] = cp*cy;\n        fwd[1] = cp*sy;\n        fwd[2] = -sp;\n        \n        right[0] = (-1*sr*sp*cy + -1*cr*-sy);\n        right[1] = (-1*sr*sp*sy + -1*cr*cy);\n        right[2] = -1*sr*cp;\n        \n        up[0] = (cr*sp*cy + -sr*-sy);\n        up[1] = (cr*sp*sy + -sr*cy);\n        up[2] = cr*cp;\n    }"
        },
        {
            "Comment": "**** STRING FUNCS ******",
            "CommentTags": [],
            "Constant": "// tested\n    XS_LIBFUNC_ATTRIB xs_strchr(const str[], chr)\n    {\n        for (new i = 0; str[i] != 0; ++i)\n        {\n            if (str[i] == chr)\n                return i;\n        }\n        return -1;\n    }\n    \n    // by JGHG, adapted\n    // removes charstotrim number of charactes from stringtotrim's\n    //  - beginning if fromleft is true\n    //  - end if fromleft is false\n    // tested\n    XS_LIBFUNC_ATTRIB xs_strtrim(stringtotrim[], charstotrim, bool:fromleft = true)\n    {\n        if (charstotrim <= 0)\n                return;\n        \n        if (fromleft)\n        {\n            new maxlen = strlen(stringtotrim);\n            if (charstotrim > maxlen)\n                charstotrim = maxlen;\n\n            // In format, input and output regions can overlap\n            format(stringtotrim, maxlen, \"%s\", stringtotrim[charstotrim]);\n        }\n        else\n        {\n            new maxlen = strlen(stringtotrim) - charstotrim;\n            if (maxlen < 0)\n                maxlen = 0;\n\n            // In format, input and output regions can overlap\n            format(stringtotrim, maxlen, \"%s\", stringtotrim);\n        }\n    }\n    \n    // by xeroblood, adapted\n    // copies characters from oldmsg to newmsg, starting at start and ending at end (_includes_ end).\n    // terminates newmsg with 0\n    // if outlen is positive, it specifies the maximal number of characters to be copied.\n    // otherwise, assumes that newmsg is at least end-start+1 characters long.\n    // tested\n    XS_LIBFUNC_ATTRIB xs_strmid(const oldmsg[], newmsg[], start, end, outlen=-1)\n    {\n        new len = strlen(oldmsg);\n        \n        if(start < 0)\n            start = 0;\n        \n        ++end;        // Include end\n        \n        if(end <= start || end > len)\n            end = len;\n\n        new j = 0, i = start;\n        for(; (i < end) && (outlen--);)\n            newmsg[j++] = oldmsg[i++];\n        \n        newmsg[j] = 0;\n    }\n    \n    // by xeroblood, adapted\n    // maxelems: maximal number of elements in output, elemsize: maximal size of one element\n    // tested\n    XS_LIBFUNC_ATTRIB xs_explode(const input[], output[][], delimiter, maxelems, elemsize)\n    {\n        new nIdx = 0;\n        new nLen = 0;\n\n        new copied = 0;\n        while(nLen < strlen(input) && nIdx < maxelems)\n        {\n            copied = copyc(output[nIdx++], elemsize, input[nLen], delimiter);\n            if (copied == elemsize)\n            {\n                // maybe it got force-stopped because of maxsize\n                // so check whether we have to skip something\n                if (input[nLen + copied] != delimiter && input[nLen + copied] != 0)\n                {\n                    new found = xs_strchr(input[nLen + copied], delimiter);\n                    if (found == -1)\n                        break;\n                    copied += found;\n                }\n            }\n            \n            nLen += copied + 1;    // +1: skip delimiter\n        }\n        return nIdx;\n    }\n    \n    // returns number of cells written.\n    XS_LIBFUNC_ATTRIB xs_implode(output[], outsize, delimiter, const input[][], elemsnum)\n    {\n        new pos = 0;\n        new copied;\n        for (new i = 0; i < elemsnum; ++i)\n        {\n            copied = copy(output[pos], outsize - pos, input[i]);\n            pos += copied;\n            if (pos >= outsize)\n                return outsize;\n            // append delimiter\n            output[pos] = delimiter;\n            ++pos;\n            // last check\n            if (pos >= outsize)\n                return outsize;\n        }\n        \n        output[--pos] = 0;        // The last char would be delimiter, so skip it.\n        return pos;\n    }\n    \n    \n    XS_LIBVAR_ATTRIB xs__replace_buf[XS_REPLACEBUF_SIZE];\n    // Replace all occurencies of what in text with with\n    // Returns number of (also partially if trimmed by len) replaced items.\n    XS_LIBFUNC_ATTRIB xs_replace(text[], len, const what[], const with[])\n    {\n        new occur = 0;\n        new i = 0;\n        new bufPos = 0;\n        new replaceLen = strlen(with);\n        new whatLen = strlen(what);\n        for (; text[i]; ++i)\n        {\n            if (text[i] == what[0])\n            {\n                new posInWhat=0;\n                new j;\n                for (j = i; j-i < replaceLen && text[j]; ++j, ++posInWhat)\n                {\n                    if (text[j] != what[posInWhat])\n                        break;\n                }\n                if (whatLen == posInWhat)\n                {\n                    for (new i2 = 0; i2 < replaceLen && bufPos < XS_REPLACEBUF_SIZE; ++i2)\n                        xs__replace_buf[bufPos++] = with[i2];\n                    i = j - 1;\n                    ++occur;\n                    if (bufPos >= XS_REPLACEBUF_SIZE)\n                        return occur;\n                    continue;\n                }\n            }\n            if (bufPos >= XS_REPLACEBUF_SIZE)\n                return occur;\n            xs__replace_buf[bufPos++] = text[i];\n        }\n        xs__replace_buf[bufPos] = 0;\n        copy(text, len, xs__replace_buf);\n        return occur;\n    }\n    \n    // replaces all occurencies of what in text with with\n    // Returns number of replaced items.\n    XS_LIBFUNC_ATTRIB xs_replace_char(text[], len, what, with)\n    {\n        // let the xs_replace function do the work\n        new arr[4];\n        arr[0] = what;\n        arr[1] = 0;\n        arr[2] = with;\n        arr[3] = 0;\n        \n        return xs_replace(text, len, arr[0], arr[2]);\n    }\n    \n    #if XS_PLATFORM == XS_AMX\n        // message_begin checking for AMX\n        xs__hook_message_begin(dest, msg_type, origin[3]={0,0,0}, player = 0)\n        {\n            xs_assert(xs_is_msg_valid(msg_type), \"message_begin called with bogus message type\");\n            return message_begin(dest, msg_type, origin, player);\n        }\n        \n        #define message_begin xs__hook_message_begin\n    #endif"
        },
        {
            "Comment": "**** MISC FUNCS ******",
            "CommentTags": [],
            "Constant": "// sets namestr to name of the command identified by cid\n    // half-tested\n    XS_LIBFUNC_ATTRIB xs_concmd_name(cid, namestr[], namelen)\n    {\n        new dummy1;\n        new dummy2[1];\n        get_concmd(cid, namestr, namelen, dummy1, dummy2, 0, 0);\n    }\n\n    // Checks whether there are at least num free visible slots\n    // half-tested\n    XS_LIBFUNC_ATTRIB bool:xs_freevisibleslots(num)\n    {    \n        new maxplayers = get_cvar_num(\"sv_visiblemaxplayers\");\n        if (maxplayers <= 0)\n            maxplayers = get_maxplayers();\n        \n        return (get_playersnum(1) <= maxplayers-num) ? true : false;\n    }\n    \n    // Returns biggest possible positive number\n    XS_LIBVAR_ATTRIB xs__maxnum = 0;\n    // tested\n    XS_LIBFUNC_ATTRIB xs_get_maxnum()\n    {\n        if (!xs__maxnum)\n        {\n            // build it\n            xs__maxnum = ((1 << (cellbits - 2)) - 1 ) | (1 << (cellbits - 2));"
        },
        {
            "Comment": "new bits = get_cellsize() * 8 - 1;\nfor (new i = 0; i < bits; ++i)\nxs__maxnum |= 1 << i;",
            "CommentTags": [],
            "Constant": "}\n        return xs__maxnum;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_get_minnum()\n    {\n        return xs_get_maxnum() + 1;\n    }\n\n\n    // *** The following two functions were created by Damaged Soul.\n    \n    // Max messages reserved by engine (DO NOT MODIFY)\n    #define XS__MAX_ENGINE_MESSAGES 63\n    // Max possible messages for mod, is 255 really the limit?\n    #define XS__MAX_POSSIBLE_MESSAGES 255\n\n    // Returns max number of messages for mod\n    XS_LIBFUNC_ATTRIB xs_get_maxmessages()\n    {\n        new name[2];\n        \n        for (new i = XS__MAX_ENGINE_MESSAGES + 1; i <= XS__MAX_POSSIBLE_MESSAGES; i++)\n            if (!get_user_msgname(i, name, 1))\n                return i - 1;\n            \n        return XS__MAX_POSSIBLE_MESSAGES;\n    }\n\n    // Returns true if msgid is a valid message\n    XS_LIBFUNC_ATTRIB bool:xs_is_msg_valid(msgid)\n    {\n        new name[2];\n        new retval = get_user_msgname(msgid, name, 1);\n        \n        if (msgid < 1 || (msgid > XS__MAX_ENGINE_MESSAGES && !retval))\n            return false;\n        \n        return true;\n    }"
        },
        {
            "Comment": "**** MANAGED TASKS *****",
            "CommentTags": [],
            "Constant": "// ***** managed task ids\n    XS_LIBFUNC_ATTRIB xs_find_freetaskid()\n    {\n        for (new i = 1; i <= XS_TASK_MANAGEDIDS; ++i)\n        {\n            if (!task_exists(i))\n                return i;\n        }\n        return -1;\n    }\n    \n    // ***** managed tasks\n    enum xs_paramtypes\n    {\n        xs_invalid = 0,\n        xs_int,\n        xs_float,\n        xs_string\n    }\n    \n    // new task\n    XS_LIBVAR_ATTRIB xs__TaskParam[    1 +                        // number of parameters\n                XS_TASK_MAXPARAMS +                        // parameter types\n                (XS_TASK_MAXPARAMSIZE char) * XS_TASK_MAXPARAMS];        // space for len + value\n    \n    XS_LIBVAR_ATTRIB Float:xs__TaskInterval = 0.0;\n    XS_LIBVAR_ATTRIB xs__TaskFlags[5];\n    XS_LIBVAR_ATTRIB xs__TaskFunc[48];\n    XS_LIBVAR_ATTRIB xs__TaskId;\n    XS_LIBVAR_ATTRIB xs__TaskRepeat;\n    \n    #define xs__TaskParamCount xs__TaskParam[0]\n    #define xs__TaskParamType[%1] xs__TaskParam[1 + %1]\n    \n    #define xs__TaskParamValue[%1] xs__TaskParam[1 + XS_TASK_MAXPARAMS + (%1 * (XS_TASK_MAXPARAMSIZE char))]\n    \n    \n    // incoming task\n    XS_LIBVAR_ATTRIB xs__ITaskParam[    1 +                        // number of parameters\n                XS_TASK_MAXPARAMS +                        // parameter types\n                (XS_TASK_MAXPARAMSIZE char) * XS_TASK_MAXPARAMS];        // space for len + value\n    XS_LIBVAR_ATTRIB xs__ITaskId;\n    \n    #define xs__ITaskParamCount xs__ITaskParam[0]\n    #define xs__ITaskParamType[%1] xs__ITaskParam[1 + %1]\n    \n    #define xs__ITaskParamValue[%1] xs__ITaskParam[1 + XS_TASK_MAXPARAMS + (%1 * (XS_TASK_MAXPARAMSIZE char))]\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_begin(Float:interval, const func[], id = 0, const flags[] = \"\", repeat = 0)\n    {\n        xs_assert(xs__TaskInterval == 0.0, \"New xs_task_begin called before xs_task_end\");\n        \n        xs__TaskInterval = interval;\n        if (xs__TaskInterval < 0.1)\n            xs__TaskInterval = 0.1;\n        \n        copy(xs__TaskFunc, 47, func);\n        xs__TaskId = id;\n        copy(xs__TaskFlags, 4, flags);\n        xs__TaskRepeat = repeat;\n        \n        xs__TaskParamCount = 0;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_pushint(value, bool:__isfl=false /*internal use only*/)\n    {\n        xs_assert(xs__TaskInterval, \"xs_task_push* called without xs_task_begin\");\n        if (xs__TaskParamCount >= XS_TASK_MAXPARAMS)\n            return 0;\n            \n        xs__TaskParamType[xs__TaskParamCount] = __isfl ? xs_float : xs_int;\n        xs__TaskParamValue[xs__TaskParamCount] = value;\n        \n        ++xs__TaskParamCount;\n        return 1;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_pushfl(Float:value)\n    {\n        return xs_task_pushint(_:value, true);\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_pushstr(const value[])\n    {\n        xs_assert(xs__TaskInterval, \"xs_task_push* called without xs_task_begin\");\n        if (xs__TaskParamCount >= XS_TASK_MAXPARAMS)\n            return 0;\n            \n        xs__TaskParamType[xs__TaskParamCount] = xs_string;\n        strpack(xs__TaskParamValue[xs__TaskParamCount], value);\n        ++xs__TaskParamCount;\n        return 1;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_end()\n    {\n        xs_assert(xs__TaskInterval, \"xs_task_end called without xs_task_begin\");\n        \n        // find a task id if needed\n        if (xs__TaskId == -1)\n        {\n            xs__TaskId = xs_find_freetaskid();\n            if (xs__TaskId == -1)\n            {\n                // not found\n                xs__TaskInterval = 0.0;\n                return -1;\n            }\n        }\n        \n        set_task(xs__TaskInterval, xs__TaskFunc, xs__TaskId, xs__TaskParam, \n            1 + xs__TaskParamCount * (XS_TASK_MAXPARAMSIZE char), xs__TaskFlags, xs__TaskRepeat);\n        \n        xs__TaskInterval = 0.0;\n        \n        return xs__TaskId;\n    }\n    \n    \n    // tested\n    #define XS_MAKE_TASKFUNC(%1) public %1(const _xs__taskparam[], _xs__taskid) if(xs__task_setup(_xs__taskparam, _xs__taskid))\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs__task_setup(const param[], taskid)\n    {\n        xs__ITaskId = taskid;\n        new len = 1 + param[0] * (XS_TASK_MAXPARAMSIZE char);\n        for (new i = 0; i < len; ++i)\n            xs__ITaskParam[i] = param[i];\n        return 1;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_readid()\n    {\n        return xs__ITaskId;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_paramcount()\n    {\n        return xs__ITaskParamCount;\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_paramtypes:xs_task_paramtype(paramid)\n    {\n        if (paramid < 0 || paramid >= xs__ITaskParamCount)\n            return xs_invalid;\n        \n        return xs_paramtypes:xs__ITaskParamType[paramid];\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_paramint(paramid)\n    {\n        if (paramid < 0 || paramid >= xs__ITaskParamCount)\n            return 0;\n        if (xs__ITaskParamType[paramid] != _:xs_int)\n            return 0;\n        \n        return xs__ITaskParamValue[paramid];\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB Float:xs_task_paramfl(paramid)\n    {\n        if (paramid < 0 || paramid >= xs__ITaskParamCount)\n            return 0.0;\n        if (xs__ITaskParamType[paramid] != _:xs_float)\n            return 0.0;\n        \n        return Float:xs__ITaskParamValue[paramid];\n    }\n    \n    // tested\n    XS_LIBFUNC_ATTRIB xs_task_paramstr(paramid, out[], maxlen)\n    {\n        #pragma unused maxlen\n        \n        if (paramid < 0 || paramid >= xs__ITaskParamCount)\n            return 0;\n        if (xs__ITaskParamType[paramid] != _:xs_string)\n            return 0;\n        \n        strunpack(out, xs__ITaskParamValue[paramid]);\n        return 1;\n    }"
        }
    ]
}